'''Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число
так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была максимально возможной. Гарантируется, что искомую
сумму получить можно. Программа должна напечатать одно число— максимально возможную сумму, соответствующую условиям
задачи.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество пар N (1≤N≤100000).
Каждая из следующих N строк содержит два натуральных числа, не превышающих 10 000.
Пример организации исходных данных во входном файле:
6
1 3
5 12
6 9
5 4
3 3
1 1
Для указанных входных данных значением искомой суммы должно быть число 32.
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.

Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_1.txt', 'r', encoding='utf-8')
# n = f.readline()
# s = 0
# razn = []
# for line in f:
#     t = list(map(int, line.split()))
#     s += max(t[0], t[1])
#     r = abs(t[1] - t[0])
#     if r % 3 != 0:
#         razn.append(r)
# f.close()
# razn.sort()
# i = 0
# if s % 3 == 0:
#     s -= razn[0]
# print(s)

'''Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число
так, чтобы сумма всех выбранных чисел не делилась на 3 и при этом была минимально возможной. Гарантируется, что искомую 
сумму получить можно. Программа должна напечатать одно число— минимально возможную сумму, соответствующую условиям 
задачи.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество пар N (1≤N≤100000).
Каждая из следующих N строк содержит два натуральных числа, не превышающих 10 000.
Пример организации исходных данных во входном файле:
6
1 3
5 12
6 9
5 4
3 3
1 1
Для указанных входных данных значением искомой суммы должно быть число 20.
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_2.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# razn = []
# s = 0
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     s += min(t[0], t[1])
#     r = abs(t[0] - t[1])
#     if r % 3 != 0:
#         razn.append(r)
# f.close()
# razn.sort()
# if s % 3 == 0:
#     s += razn[0]
# print(s)

'''Последовательность натуральных чисел характеризуется числом Х— наибольшим числом, кратным 14 и являющимся 
произведением двух элементов последовательности с различными номерами. Гарантируется, что хотя бы одно такое 
произведение в последовательности есть.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество чисел N (1≤N≤100000). В 
каждой из последующих N строк записано одно натуральное число, не превышающее 1000.
Пример организации исходных данных во входном файле:
5
40
1000
7
28
55
Пример выходных данных для приведённого выше примера входных данных:
28000
В ответе укажите два числа: сначала значение искомого произведения для файла А, затем для файла B.'''
# f = open('27_4.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# p = 0
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         m = a[i] * a[j]
#         if m % 14 == 0 and m > p:
#             p = m
# print(p)

# f = open('27_4.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a14 = []
# a7 = []
# a2 = []
# max7 = 0
# max2 = 0
# max14 = 0
# max1 = 0
# for line in f:
#     t = int(line)
#     if t % 14 == 0:
#         a14.append(t)
#         max14 = max(max14, t)
#     elif t % 2 == 0:
#         a2.append(t)
#         max2 = max(max2, t)
#     elif t % 7 == 0:
#         a7.append(t)
#         max7 = max(max7, t)
#     max1 = max(max1, t)
# f.close()
# max10 = max(max14*max1, max7*max2)
# print(max10)

'''На вход программы поступает последовательность из N целых положительных чисел. Рассматриваются все пары различных
элементов последовательности (элементы пары не обязаны стоять в последовательности рядом, порядок элементов в паре не 
важен). Необходимо определить количество пар, для которых произведение элементов делится на 26.
В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 60000). В каждой из последующих N строк записано 
одно целое положительное число, не превышающее 10 000. В качестве результата программа должна напечатать одно число:
количество пар, в которых произведение элементов кратно 26.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество пар N (1≤N≤100000). В
каждой из последующих N строк записано одно натуральное число, не превышающее 1000.
Пример организации исходных данных во входном файле:
4
2
6
13
39
Пример выходных данных для приведённого выше примера входных данных:
4
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.'''
# f = open('27_5.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# k = 0
# for line in f:
#     a.append(int(line))
# f.close()                       # aвторское
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         if a[i] * a[j] % 26 == 0:
#             k += 1
# print(k)


# f = open('27_5.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# k2 = 0
# k13 = 0
# k26 = 0
# for line in f:
#     t = int(line)
#     if t % 26 == 0:
#         k26 += 1
#     elif t % 13 == 0:
#         k13 += 1
#     elif t % 2 == 0:
#         k2 += 1
# f.close()
# k = k26 * (n - k26) + (k26 * (k26 - 1)) // 2 + (k2 * k13)
# print(k)


'''Дана последовательность N целых положительных чисел. Рассматриваются все пары элементов последовательности, разность
которых чётна, и в этих парах, по крайней мере, одно из чисел пары делится на 17. Порядок элементов в паре неважен. 
Среди всех таких пар нужно найти и вывести пару с максимальной суммой элементов. Если одинаковую максимальную сумму 
имеет несколько пар, можно вывести любую из них. Если подходящих пар в последовательности нет, нужно вывести два нуля.
Входные данные.
Файл A
Файл B
В первой строке входных данных задаётся количество чисел N (2 ≤ N ≤ 10000). В каждой из последующих N строк записано
одно натуральное число, не превышающее 10000.
Пример организации исходных данных во входном файле:
5
34
12
51
52
51
Пример выходных данных для приведённого выше примера входных данных:
51 51
В ответе укажите четыре числа: сначала значение искомой пары для файла А (два числа через пробел), затем для файла B
(два числа через пробел). Числа пар впишите в порядке убывания.
Ответ: 
Пояснение. Из данных пяти чисел можно составить три различные пары, удовлетворяющие условию: (34, 12), (34, 52), 
(51, 51). Наибольшая сумма получается в паре (51, 51). Эта пара допустима, так как число 51 встречается в исходной
 последовательности дважды.'''
# f = open('27_7.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# k = 0
# max1 = 0
# x1 = x2 = 0
# for line in f:
#     a.append(int(line))
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         if a[i] % 17 == 0 or a[j] % 17 == 0:
#             if abs(a[i] - a[j]) % 2 == 0:
#                 k += 1
#                 if a[i] + a[j] > max1:
#                     max1 = a[i] + a[j]
#                     x1 = a[i]
#                     x2 = a[j]
# f.close()
# print(x2, x1)


# f = open('27_7.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# ch = []
# nec = []
# a17 = []
# for line in f:
#     t = int(line)
#     if t % 17 == 0:
#         a17.append(t)
#     if t % 2 == 0:
#         ch.append(t)
#     else:
#         nec.append(t)
# f.close()
# ch.sort()
# nec.sort()
# a17.sort()
# m = a17[-1]
# if m % 2 == 0:
#     if ch[-1] != m:
#         print(m, ch[-1])
#     else:
#         print(m, ch[-2])
# else:
#     if nec[-1] != m:
#         print(m, nec[-1])
#     else:
#         print(m, nec[-2])

'''(№ 5316) (Л. Шастин) На вход программе поступает последовательность натуральных чисел. Найдите количество 
подпоследовательностей исходной последовательности, которые не содержат в себе трёх идущих друг за другом единиц.
Входные данные. Даны два входных файла (файл A и файл B), содержит в первой строке число N (2 ≤ N ≤ 5 000 000) –
количество чисел в последовательности. Каждая из следующих N строк содержит одно натуральное число, не превышающее 10000
Пример входного файла:
4
1
1
1
2
В этой последовательности восемь подходящих подпоследовательностей: {1}; {1, 1}; {1}; {1, 1}; {1, 1, 2}; {1}; {1, 2};
{2}. Ответ: 8.
В ответе укажите два числа: сначала искомое значение для файла А, затем для файла B.'''
# f = open('27_starg.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# k = 0
# k1 = 0
# c = 0
# for i in range(n):
#     if a[i] == 1:
#         k1 += 1
#     else:
#         k1 = 0
#     if k1 == 3:
#         k += 2
#         k1 = 2
#         c = 2
#     else:
#         k += c + 1
#         c += 1
# print(k)


'''Набор данных состоит из пар натуральных чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма
всех выбранных чисел делилась на 3 и при этом была максимально возможной.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит число N— общее количество пар в наборе. Каждая из следующих N строк содержит два
натуральных числа, не превышающих 10000.
Пример организации исходных данных во входном файле:
6
1 3
5 10
6 9
5 4
3 3
1 1
Для указанных данных искомая сумма равна 30.
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.
 
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_12.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# s = 0
# a1 = []
# a2 = []
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     s += max(t)
#     r = abs(t[1] - t[0])
#     if r % 3 == 1:
#         a1.append(r)
#     elif r % 3 == 2:
#         a2.append(r)
# f.close()
# a1.sort()
# a2.sort()
# if s % 3 == 2:
#     s -= min(a2[0], a1[0] + a1[0])
# elif s % 3 == 1:
#     s -= min(a2[0] + a2[1], a1[0])
# print(s)


'''В текстовом файле записан набор натуральных чисел, не превышающих 10^8. Гарантируется, что все числа различны.
Из набора нужно выбрать три числа, сумма которых делится на 3. Какую наибольшую сумму можно при этом получить?
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество чисел в наборе. Каждая из следующих N строк 
содержит одно число.
Пример входного файла:
4
5
8
14
11
В данном случае есть четыре подходящие тройки: 5, 8, 11 (сумма 24); 5, 8 14 (сумма 27); 5, 14 11 (сумма 30) и 8, 14, 11
(сумма 33). В ответе надо записать число 33.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа:
сначала значение искомой суммы для файла A, затем для файла B.'''
# f = open('27_18.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for i in f:
#     a.append(int(i))
# f.close()
# m = 0
# for i in range(n - 2):
#     for j in range(i + 1, n - 1):
#         for h in range(j + 1, n):
#             s = a[i] + a[j] + a[h]
#             if s % 3 == 0 and s > m:
#                 m = s
# print(m)

# f = open('27_18.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a0 = []
# a1 = []
# a2 = []
# for line in f:
#     t = int(line)
#     if t % 3 == 0:
#         a0.append(t)
#     elif t % 3 == 1:
#         a1.append(t)
#     elif t % 3 == 2:
#         a2.append(t)
# f.close()
# a0.sort()
# a1.sort()
# a2.sort()
# s = max(a0[-1] + a0[-2] + a0[-3], a1[-1] + a1[-2] + a1[-3], a2[-1] + a2[-2] + a2[-3], a0[-1] + a1[-1] + a2[-1])
# print(s)

'''
Набор данных состоит из пар натуральных чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех 
выбранных чисел делилась на 3 и при этом была минимально возможной.
Первая строка входного файла содержит число N— общее количество пар в наборе. Каждая из следующих N строк содержит два 
натуральных числа, не превышающих 10000.
Пример организации исходных данных во входном файле:
6
1 3
5 12
6 9
5 4
3 3
1 1
Для указанных данных искомая сумма равна 21.
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_13.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# s = 0
# a1 = []
# a2 = []
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     s += min(t)
#     r = abs(t[1] - t[0])
#     if r % 3 == 1:
#         a1.append(r)
#     elif r % 3 == 2:
#         a2.append(r)
# f.close()
# a1.sort()
# a2.sort()
# if s % 3 == 2:
#     s += min(a1[0], a2[0] + a2[1])
# elif s % 3 == 1:
#     s += min(a2[0], a1[0] + a1[0])
# print(s)


'''В текстовом файле записан набор натуральных чисел, не превышающих 10^8. Гарантируется, что все числа различны. Из 
набора нужно выбрать три числа, сумма которых делится на 3. Какую наименьшую сумму можно при этом получить?
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество чисел в наборе. Каждая из следующих N строк 
содержит одно число.
Пример входного файла:
4
5
8
14
11
В данном случае есть четыре подходящие тройки: 5, 8, 11 (сумма 24); 5, 8, 14 (сумма 27); 5, 14 11 (сумма 30) и 8, 14, 
11 (сумма 33). В ответе надо записать число 24.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа:
сначала значение искомой суммы для файла A, затем для файла B.'''
# f = open('27_19.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# m = 10000000000
# for i in range(n - 1):
#     for j in range(i + 1, n - 1):
#         for h in range(j + 1, n):
#             s = a[i] + a[j] + a[h]
#             if s % 3 == 0 and s < m:
#                 m = s
# print(m)

# f = open('27_19.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a0 = []
# a1 = []
# a2 = []
# for line in f:
#     t = int(line)
#     if t % 3 == 0:
#         a0.append(t)
#     elif t % 3 == 1:
#         a1.append(t)
#     elif t % 3 == 2:
#         a2.append(t)
# f.close()
# a0.sort()
# a1.sort()
# a2.sort()
# s = min(a0[0] + a0[1] + a0[2], a1[0] + a1[1] + a1[2], a2[0] + a2[1] + a2[2], a0[0] + a1[0] + a2[0])
# print(s)

'''На вход программы поступает последовательность из N натуральных чисел. Рассматриваются все пары различных элементов
последовательности, у которых различные остатки от деления на d=160 и хотя бы одно из чисел делится на p=7. Среди таких
пар, необходимо найти и вывести пару с максимальной суммой элементов.
Входные данные.
Файл A
Файл B
В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно
натуральное число, не превышающее 10000. В качестве результата программа должна напечатать элементы искомой пары. Если
среди найденных пар максимальную сумму имеют несколько, то можно напечатать любую из них. Если таких пар нет, то вывести
два нуля.
Пример организации исходных данных во входном файле:
4
168
7
320
328
Пример выходных данных для приведённого выше примера входных данных:
168 320
В ответе укажите четыре числа: сначала значение искомой пары для файла А (два числа через пробел по возрастанию), затем
для файла B (два числа через пробел по возрастанию).'''
# f = open('27_8.txt', 'r', encoding='utf-8')
# a = []
# n = int(f.readline())
# for line in f:
#     a.append(int(line))
# f.close()
# max1 = 0
# max2 = 0
# max3 = 0
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         if a[i] % 160 != a[j] % 160 and (a[i] % 7 == 0 or a[j] % 7 == 0):
#             if a[i] + a[j] > max1:
#                 max1 = a[i] + a[j]
#                 max2 = a[i]
#                 max3 = a[j]
# print(max2, max3)

# f = open('27_8.txt', 'r', encoding='utf-8')
# s = [0] * 160   # список максимальных чисел у которых остаток от деления на 160 = их индексу в списке
# max7 = 0   # максимальное число кратное 7
# n = int(f.readline())  # кол-во чисел
# for line in f:
#     t = int(line)
#     d = t % 160  # остаток от деления на 160
#     s[d] = max(s[d], t)  # элемент на индексе d заменяем на максимальный с таким остатком d
#     if t % 7 == 0 and t > max7:
#         max7 = t
# f.close()
# s.sort(reverse=True)
# i = 0
# while s[i] % 160 == max7 % 160:
#     i += 1
# print(max7, s[i])


'''Дана последовательность N целых положительных чисел. Необходимо определить количество пар элементов этой 
последовательности, сумма которых делится на m=80 и при этом хотя бы один элемент из пары больше b=50.
Входные данные.
Файл A
Файл B
В первой строке входных данных задаётся количество чисел N (2 ≤ N ≤ 10 000). В каждой из последующих N строк записано
одно натуральное число, не превышающее 10000.
Пример организации исходных данных во входном файле:
6
40
40
120
30
50
110
Пример выходных данных для приведённого выше примера входных данных:
3
В ответе укажите два числа: сначала количество пар для файла А, затем для файла B.'''
# f = open('27_9.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# k = 0
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         if ((a[i] + a[j]) % 80 == 0) and (a[i] > 50 or a[j] > 50):
#             k += 1
# print(k)

# f = open('27_9.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = [0] * 80  # список счетчиков чисел > 50, каждый индекс которых соответствует остатку от деления на 80
# b = [0] * 80  # список счетчиков чисел <= 50, каждый индекс которых соответствует остатку от деления на 80
# for line in f:
#     t = int(line)
#     d = t % 80  # остаток от деления числа на 80
#     if t > 50:
#         a[d] += 1
#     else:
#         b[d] += 1
# k = a[0] * (a[0] - 1) // 2 + a[0] * b[0]  # особая обработка для кол-ва чисел с остатком 0 от дел на 80
# f.close()
# количество чисел из списка а(больше 50) с остатком i образуют пары с числами из списка а с остатком 80 - i,
# с числами из списка b (<= 50) с остатком также 80 - i, кол-во чисел из списка а с остатком 80 - i также образуют пару
# с кол-вом чисел из списка b с остатком i (там где числа там кол-во)
# for i in range(1, 40):
#     k += (a[i] * a[80 - i] + a[i] * b[80 - i] + b[i] * a[80 - i])
# k += a[40] * (a[40] - 1) // 2 + a[40] * b[40] # особая обработка для кол-ва чисел с остатком 40 от дел на 80
# print(k)


'''На вход программы поступает последовательность из n целых положительных чисел. Рассматриваются все пары элементов
последовательности ai и aj, такие что i < j и ai > aj (первый элемент пары больше второго; i и j— порядковые номера 
чисел в последовательности входных данных). Среди пар, удовлетворяющих этому условию, необходимо найти и напечатать пару
с максимальной суммой элементов, которая делится на m=120. Если среди найденных пар максимальную сумму имеют несколько,
то можно напечатать любую из них. 
Входные данные.
Файл A
Файл B
В первой строке входных данных задаётся количество чисел n (2 ≤ n ≤ 12 000).
В каждой из последующих n строк записано одно целое положительное число, не превышающее 10 000.
В качестве результата программа должна напечатать элементы искомой пары. Если таких пар несколько, можно вывести любую
из них. Гарантируется, что хотя бы одна такая пара в последовательности есть.
Пример организации исходных данных во входном файле:
6
60
140
61
100
300
59
Пример выходных данных для приведённого выше примера входных данных:
140 100
В ответе укажите четыре числа: сначала искомую пару чисел для файла А (два числа через пробел), затем для файла B (два
#  числа через пробел).'''
# f = open('27_10.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# maxi = 0
# maxj = 0
# max1 = 0
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         s = a[i] + a[j]
#         if a[i] > a[j] and s % 120 == 0 and s > max1:
#             max1 = s
#             maxi = a[i]
#             maxj = a[j]
# print(maxi, maxj)


'''На вход программы поступает последовательность из N целых положительных чисел. Рассматриваются все пары различных 
элементов последовательности (элементы пары не обязаны стоять в последовательности рядом), такие что ai>aj при i<j≤N.
Среди пар, удовлетворяющих этому условию, необходимо найти и вывести пару с максимальной суммой элементов, которая
делится на 120. Если среди найденных пар максимальную сумму имеют несколько, то можно напечатать любую из них. Если пар
заданным условием нет, то программа должна вывести 00.
Входные данные.
Файл A
Файл B
В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В каждой из последующих N строк записано одно
натуральное число, не превышающее 10000.
В качестве результата программа должна напечатать элементы искомой пары. Если таких пар несколько, можно вывести любую
из них.
Пример организации исходных данных во входном файле:
7
1
119
2
118
3
237
123
Пример выходных данных для приведённого выше примера входных данных:
237 123
В ответе укажите четыре числа: сначала значение искомой суммы для файла А (два числа через пробел), затем для файла 
B (два числа через пробел).'''
# f = open('27_11.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# max1 = 0
# maxi = 0
# maxj = 0
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         s = a[i] + a[j]
#         if a[i] > a[j] and i < j and j <= n and s > max1 and s % 120 == 0:
#             max1 = s
#             maxi = a[i]
#             maxj = a[j]
# print(maxi, maxj)

'''Набор данных состоит из троек натуральных чисел. Необходимо распределить все числа на три группы, при этом в каждую
группу должно попасть ровно одно число из каждой исходной тройки. Сумма всех чисел в первой группе должна быть чётной, 
во второй— нечётной. Определите максимально возможную сумму всех чисел в третьей группе.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит число N— общее количество троек в наборе. Каждая из следующих N строк содержит три
натуральных числа, не превышающих 10000.
Пример входного файла:
3
1 2 3
5 12 4
6 9 7
Для указанных данных искомая сумма равна 24, она соответствует такому распределению чисел по группам: (1,5,6), (2,4,7),
 (3,12,9).
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа: 
сначала значение искомой суммы для файла A, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_14.txt', 'r', encoding='utf-8')
# n = int(f.readline())  # общее количество троек в наборе
# r1 = []  # список нечетных разностей
# r2 = []  # список четных разностей
# s12 = 0  # сумма чисел первой и второй группы
# s3 = 0  # сумма чисел третьей группы
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     t.sort()  # сортировка по возрастанию
#     s3 += t[-1]  # добавляем в сумму третьей группы максимальное число
#     s12 = s12 + t[0] + t[1]  # добавляем в сумму чисел первой и второй группы 2 наименьших числа
#     r = t[-1] - t[0]  # разность максимального и минимального числа
#     if r % 2 == 0:  # если разность четна
#         r2.append(r)
#     else:  # если разность нечетна
#         r1.append(r)
#     r = t[-1] - t[1]  # разность максимального и второго максимального числа
#     if r % 2 == 0:
#         r2.append(r)
#     else:
#         r1.append(r)
# if s12 % 2 == 0:  # если условие первой и второй группы нарушено для одной из групп, то ситуацию можно выправить только засчет 3 группы
#     s3 -= min(r1)  # отнимаем наименьшую нечетную разность
# print(s3)

'''Набор данных состоит из нечётного количества пар натуральных чисел. Необходимо выбрать из каждой пары ровно одно 
число так, чтобы чётность суммы выбранных чисел совпадала с чётностью большинства выбранных чисел и при этом сумма 
выбранных чисел была как можно больше. Определите максимальную сумму, которую можно получить при таком выборе. 
Гарантируется, что удовлетворяющий условиям выбор возможен.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит число N— общее количество пар в наборе. Каждая из следующих N строк содержит два 
натуральных числа, не превышающих 10000.
Пример входного файла:
5
15 8
5 11
6 3
7 2
9 14
Для указанных данных надо выбрать числа 15, 11, 6, 7 и 14. Большинство из них нечётны, сумма выбранных чисел равна 53 и
тоже нечётна. В ответе надо записать число 53.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа: 
сначала значение искомой суммы для файла A, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных 
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_16.txt', 'r', encoding='utf-8')
# n = int(f.readline())  # количество пар в наборе
# k1 = 0  # кол-во нечетных чисел
# k2 = 0  # кол-во четных чисел
# r = []  # список разности
# s = 0  # сумма выбранных чисел
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     t.sort()
#     s += t[1]  # добавляем к сумме максимальное число из пары
#     if t[1] % 2 == 1:  # если добавленное число нечетно
#         k1 += 1
#     else:
#         k2 += 1
#     if (t[1] - t[0]) % 2 == 1:  # если числа в паре разной четности
#         if t[1] % 2 == 1:  # если добавляемое число нечетно
#             r.append([t[1] - t[0], 1])  # добавляем в список разности пару: разность и знак четности включенного в сумму числа
#         else:
#             r.append([t[1] - t[0], 2])
# f.close()
# r.sort()  # сортируем список разности по возрастанию разности
# while (s % 2 == 0 and k1 >= k2) or (s % 2 == 1 and k2 >= k1):  # пока условие задачи неверно
#     s -= r[0][0]  # от суммы отнимаем наименьшую доступную разность
#     if r[0][1] == 1:  # если меняем нечетное число на четное
#         k1 -= 1  # нечетное убирается  из суммы
#         k2 += 1  # четное добавляется
#     else:
#         k1 += 1  # нечетное добавляется в сумм
#         k2 -= 1  # четное убирается
#     r.pop(0)  # удаляем из списка разностей  использываемую разность
# print(s)

'''В текстовом файле записан набор пар натуральных чисел, не превышающих 10 000. Необходимо выбрать из набора некоторые 
пары так, чтобы первое число в каждой выбранной паре было нечётным, сумма бо́льших чисел во всех выбранных парах была 
нечётной, а сумма меньших— чётной. Какую наибольшую сумму чисел во всех выбранных парах можно при этом получить?
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество пар в наборе. Каждая из следующих N строк
содержит пару чисел.
Пример входного файла:
4
5 2
8 15
7 14
11 9
В данном случае есть три подходящие пары: (5, 2), (7, 14) и (11, 9). Пара (8, 15) не подходит, так как в ней первое 
число чётное. Чтобы удовлетворить требования, надо взять пары (7, 14) и (11, 9). Сумма бо́льших чисел в этом случае равна
25, сумма меньших равна 16. Общая сумма равна 41. В ответе надо указать число 41.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа:
сначала значение искомой суммы для файла A, затем для файла B.'''
# f = open('27_20.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     if t[0] % 2 == 1:
#         a.append(sorted(t))
# f.close()
# s1 = 0
# s2 = 0
# for t in a:
#     s1 += t[0]
#     s2 += t[1]
# def Maxsumm(x):
#     return x[0] + x[1]
#
#
# a.sort(key=lambda x:Maxsumm(x))
# print(s1)
# print(s2)
# print(a)
#
# print(s1 + s2 - 25 - 36 - 41 - 71)
# print(s1 + s2 - 52 - 195)

'''Имеется набор данных, состоящий из троек положительных целых чисел. Необходимо выбрать из каждой тройки ровно одно 
число так, чтобы сумма всех выбранных чисел не делилась на k=109 и при этом была максимально возможной. Гарантируется,
что искомую сумму получить можно. Программа должна напечатать одно число— максимально возможную сумму, соответствующую
условиям задачи.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество троек N (1≤N≤1000000).
Каждая из следующих N строк содержит три натуральных числа, не превышающих 20000.
Пример организации исходных данных во входном файле:
6
1 3 7
5 12 6
6 9 11
5 4 8
3 5 4
1 1 1
Для указанных входных данных, в случае, если k=5, значением искомой суммы является число 44.
В ответе укажите два числа: сначала значение искомой суммы для файла А,'''
# f = open('27_21.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# s = 0
# r = []
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     t.sort()
#     #   print(t)
#     s += t[-1]
#     p = t[-1] - t[0]
#     if p % 109 != 0:
#         r.append(p)
#     p = t[-1] - t[1]
#     if p % 109 != 0:
#         r.append(p)
# f.close()
# if s % 109 == 0:
#     s = s - min(r)
# print(s)

'''Дана последовательность натуральных чисел. Назовём парой любые два числа из последовательности. Необходимо определить
количество пар, в которых сумма чисел в паре делится без остатка на 3, а их произведение— на 4096.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество чисел в наборе. Каждая из следующих N
строк содержит одно число, не превышающее 40 000. Гарантируется, что число в ответе не превышает 2·109.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа:
сначала искомое значение для файла A, затем—для файла B.'''
# f = open('27_33.txt', 'r', encoding='utf-8')
# n = int(f.readline())  # общее кол-во чисел
# a = []  # список чисел
# for line in f:
#     a.append(int(line))
# f.close()
# k = 0  #  счетик кол-ва подходящих пар
# for i in range(n - 1):
#     for j in range(i + 1, n):
#         if (a[i] + a[j]) % 3 == 0 and (a[i] * a[j]) % 4096 == 0:  # если пара удовлетворяет условию
#             k += 1
# print(k)
# f = open('27_33.txt', 'r', encoding='utf-8')
# k0 = [0] * 12  # список кол-ва чисел(остаток % на 3 == 0) включающих степень двойки от 1 до 12, индекс - это степень минус 1
# k1 = [0] * 12  # список кол-ва чисел(остаток % на 3 == 1) включающих степень двойки от 1 до 12, индекс - это степень минус 1
# k2 = [0] * 12  # список кол-ва чисел(остаток % на 3 == 2) включающих степень двойки от 1 до 12, индекс - это степень минус 1
# m0 = 0  # кол-во чисел не делящихся на 2 с остатком 0 от деления на 3
# m1 = 0  # кол-во чисел не делящихся на 2 с остатком 1 от деления на 3
# m2 = 0  # кол-во чисел не делящихся на 2 с остатком 2 от деления на 3
# n = int(f.readline())  # кол-во всех чисел
# for line in f:
#     q = 0  # флаг того, что число содержит в составе степень двойки
#     t = int(line)
#     for i in range(12, 0, -1):  # проверяем наличие i-той степени двойки в числе
#         if t % (2**i) == 0:  # если число содержит в себе два в степени i
#             q = 1  # помечаем флаг == 1
#             if t % 3 == 0:  # если остаток от деления == 0
#                 k0[i - 1] += 1
#             elif t % 3 == 1:  # если остаток от деления == 1
#                 k1[i - 1] += 1
#             else:  # если остаток от деления == 2
#                 k2[i - 1] += 1  # индекс степеи на единицу < чем степень
#             break
#     if not(q):  # если число не содержало в себе степень двойки
#         if t % 3 == 0:
#             m0 += 1
#         elif t % 3 == 1:
#             m1 += 1
#         else:
#             m2 += 1
# f.close()
# s = 0  # кол-во подходящих пар
# # обработка чисел делящихся на 3 без остатка и имеющих в свое составе 4096 - 12-я степень двойки
# # (k0[11] * (k0[11] - 1) // 2 - пары таких чисел между собой
# # k0[11] * sum(k0[:-1]) - это пара такого числа с числами имеющими любую степень двойки до 12-ой
# #  k0[11] * m0 - пара такого числа с числом не имеющего двойки в составе, но % 3 == 0
# s += (k0[11] * (k0[11] - 1) // 2 + k0[11] * sum(k0[:-1]) + k0[11] * m0)
# # обработка чисел делящихся на 3 без остатка и имеющих степень < 12
# # k0[i] * sum(k0[10-i:i]) - пара числа с числом с наименьшей подходящей степенью двойки до степени самого числа
# # k0[i] * (k0[i] - 1) // 2 - пары таких чисел между собой
# # идем до шестой степени(индекс 5), так как меньшая степень не может быть взята сама с собой
# for i in range(10, 4, -1):
#     s += (k0[i] * sum(k0[10-i:i]) + k0[i] * (k0[i] - 1) // 2)
# # обработка чисел с % 3 == 1 и имеющих в своем составе 4096
# # k1[11] * sum(k2 - пара такого числа с любым числом со степенью двойки в составе и % 3 == 2
# # k1[11] * m2 - пара такого числа с числом не имеющего двойки в составе и % 3 == 2
# s += (k1[11] * sum(k2) + k1[11] * m2)
# # обработка пар чисел с % 3 == 1
# # пара числа с наименьшей подходящей степенью двойки до 11 степени включительно из списка кол-ва чисел с % 3 == 2
# for i in range(10, -1, -1):
#     s += (k1[i] * sum(k2[10-i:11]))
# # обработка чисел с % 3 == 2 и имеющих в своем составе 4096
# # k2[11] * m1 - пара такого числа с числом не имеющего двойки в составе и % 3 == 1
# # k2[11] * sum(k1[:11] - пара такого числа с любым числом со степенью двойки в составе(кроме 12 степени, так как ее уже включили) и % 3 == 1
# s += (k2[11] * m1) + k2[11] * sum(k1[:11])
# print(s)


'''
Набор данных состоит из троек натуральных чисел. Необходимо распределить все числа на три группы, при этом в каждую 
группу должно попасть ровно одно число из каждой исходной тройки. Сумма всех чисел в первой группе должна быть чётной,
во второй— нечётной. Определите минимально возможную сумму всех чисел в третьей группе.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит число N— общее количество троек в наборе. Каждая из следующих N строк содержит три
натуральных числа, не превышающих 10000.
Пример входного файла:
3
1 2 3
8 12 4
6 9 7
Для указанных данных искомая сумма равна 11, она соответствует такому распределению чисел по группам: (2,8,7), (3,12,9),
 (1,4,6).
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа:
сначала значение искомой суммы для файла A, затем для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных 
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_15.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# r1 = []
# r2 = []
# s12 = 0
# s3 = 0
# for line in f:
#     t = line.split()
#     t = list(map(int, t))
#     t.sort()
#     s3 += t[0]
#     s12 = s12 + t[1] + t[-1]
#     r = t[-1] - t[0]
#     if r % 2 == 0:
#         r2.append(r)
#     else:
#         r1.append(r)
# if s12 % 2 == 0:
#     s3 += min(r1)
# print(s3)


'''На вход программы поступает последовательность из целых положительных чисел. Необходимо выбрать такую 
подпоследовательность подряд идущих чисел, чтобы их сумма была максимальной и делилась на 89, а также её длину. Если
таких подпоследовательностей несколько, выбрать такую, у которой длина меньше.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество чисел N (2≤N≤68000). В
каждой из последующих N строк записано одно целое положительное число, не превышающее 10000. Программа должна вывести
длину найденной последовательности.
Пример входного файла:
8
2
3
4
93
42
34
5
95
Для делителя 50 при указанных входных данных значением искомой суммы должно быть число 100 (3+4+93 или 5+95).
Следовательно, ответ на задачу— 2. В ответе укажите два числа: сначала значение искомой длины для файла A, затем для 
файла B. '''
# f = open('27_23.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for i in f:
#     a.append(int(i))
# m = 0
# dlin = 0
# for i in range(n):
#     s = 0
#     k = 0
#     for j in range(i, n):
#         s += a[j]
#         k += 1
#         if s % 89 == 0:
#             if s > m or (s == m and k < dlin):
#                 m = s
#                 dlin = k
# print(dlin)

'''На вход программы поступает последовательность из целых положительных чисел. Необходимо выбрать такую
подпоследовательность подряд идущих чисел, чтобы их сумма была максимальной и делилась на 89, а также её длину. Если
таких подпоследовательностей несколько, выбрать такую, у которой длина меньше.
Входные данные.
Файл A
Файл B
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество чисел N (2≤N≤68000). В 
каждой из последующих N строк записано одно целое положительное число, не превышающее 10000. Программа должна вывести 
длину найденной последовательности.
Пример входного файла:
8
2
3
4
93
42
34
5
95
Для делителя 50 при указанных входных данных значением искомой суммы должно быть число 100 (3+4+93 или 5+95).
Следовательно, ответ на задачу— 2. В ответе укажите два числа: сначала значение искомой длины для файла A, 
затем для файла B.'''
# f = open('27_231.txt', 'r', encoding='utf-8')
# n = int(f.readline())  #кол-во последовательности
# k = 89  # k - число, на которое сумма должна делиться без остатка
# s = 0  # общая сумма чисел
# mins = {0: (0, 0)}  # словарь с минимальной суммой по каждому остатку числа k
# #  ключ словаря (до :)- это остаток от деления на k(89)
# #  значение от ключа(после :) - это кортеж: пара в которой 1-ое число-минимальная сумма с остатком на k(89) = ключу
# #  второе число - это кол-во чисел, из которых состоит данная сумма
# #  всегда добавляем первую пару для остатка ноль(сразу добавляем ее в mins)
# res = []  #  список подходящих сумм под последовательности и соответствующих им кол-ву чисел
# for i in range(1, n + 1):   #  проходимся по каждому числу, i-номер по счету числа
#     s += int(f.readline())  #  к общей сумме добавляем очередное число
#     if s % k in mins:  #  если до этого словарь mins уже хранил сумму подпоследовательности чисел которые были до этого с таким же остатком на 89(k)
#         res += [(s - mins[s % k][0], mins[s % k][1] - i)]  #  из текущей подпоследовательности выкидываем числа, которые давали нам такой же остаток
#         #  и в итоге получаем подпоследовательность делящуюся на 89
#         #  пару сумму чисел найденной подпоследовательности и кол-во чисел ее составляющих добавляем в rez
#         #  кол-во чисел добавляем с минусом, так как, если max сумма будет одинаковой в rez нужно выбрать минимальное кол-во чисел ее составляющтх
#     else:  #  если до этого словарь mins не хранил подпоследовательность чисел с таким же остатком на 89
#         mins[s % k] = (s, i)  #  в mins добавляем ключ с данным остатком от деления на 89 и значением ввиде пары:сумма
#         # подпоследовательности, кол-ва чисел и ее составляющих
# print(-max(res)[1])  #  находим максимальную по сумме подходящую подпоследовательность. Если таких несколько,
# # то с минимальным по модулю кол-ву чисел ее составляющих и выводим само кол-во(минус - так как кол-во хранится ввиде отрицательных чисел)


'''Дана последовательность натуральных чисел. Необходимо определить количество её непрерывных подпоследовательностей, 
сумма элементов которых кратна 999.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество чисел в наборе. Каждая из следующих N строк 
содержит одно число. Гарантируется, что общая сумма всех чисел и число в ответе не превышают 2·109 по абсолютной 
величине.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа: 
сначала значение искомой суммы для файла A, затем для файла B.'''
# f = open('27_30.txt', 'r', encoding='utf-8')
# n = int(f.readline())  #  кол- во всех чисел
# k = 0  #  кол-во подпоследовательностей, котрое делится на 999
# s = 0  #  сумма всех чисел
# ost_count = [0] * 1000  #  спискок кол-ва чисел с остатком на 999 = индексу элемента в списке
# for i in range(1, n + 1):  #  проходимся по каждому числу. i - это его номер по счету
#     t = int(f.readline())
#     s += t  #  добавляем к сумме число
#     if s % 999 == 0:  #  если сумма кратна 999, то увеличиваем счетчик
#         k += 1
#     #  далее добавляем кол-во подпоследовательностей, отняв сумму каждой из текущей подпоследовательности,
#     #  мы получим подпоследовательность делящуюся на 999
#     k += ost_count[s % 999]
#     ost_count[s % 999] += 1  #  добавляем +одну последовательность с таким остактком
# print(k)






# f = open('27_30.txt', 'r', encoding='utf-8')
# n = int(f.readline())
# a = []
# for line in f:
#     a.append(int(line))
# f.close()
# k = 0
# for i in range(n):
#     s = 0
#     for j in range(i, n):
#         s += a[j]
#         if s % 999 == 0:
#             k += 1
# print(k)



'''Метеорологическая станция ведёт наблюдение за количеством выпавших осадков. Показания записываются каждую минуту в 
течении N минут. Определяется пара измерений, между которыми прошло не менее K минут. Найдите максимальную сумму 
показаний среди таких пар.
Входные данные
Даны два входных файла (A и B), каждый из которых в первой строке содержит число N - количество измерений, во второй 
строке K - минимальное количество минут между искомыми измерениями. В каждой из следующих N строк находится число: 
количество выпавших осадков.
В ответе укажите два числа: сначала значение искомой величины для файла A, затем - для файла B.
Предупреждение: для обработки файла B не следует использовать переборный алгоритм, вычисляющий сумму для всех возможных 
вариантов, поскольку написанная по такому алгоритму программа будет выполняться слишком долго.'''
# f = open('27_demo.txt', 'r', encoding='utf-8')
# a = []  # список осадков
# n = int(f.readline())  # общее кол-во минут, когда записывались показания об осадках
# k = int(f.readline())  # фиксированное кол-во минут, которое должно пройти между измерениями
# for line in f:
#     a.append(int(line))
# f.close()
# max1 = 0  # для максимальной суммы показаний пары, между измерениями осадков которой прошло не менее K минут
# for i in range(n - 1):  # пара-это два различных измерения
#     for j in range(i + k, n):  # чтобы сразу начинать с элемента с этой разницей K(просто оптимизация)
#         max1 = max(max1, a[i] + a[j])
# print(max1)



# f = open('27_demo.txt', 'r', encoding='utf-8')
# a = []  # список осадков
# n = int(f.readline())  # общее кол-во минут, когда записывались показания об осадках
# k = int(f.readline())  # фиксированное кол-во минут, которое должно пройти между измерениями
# for line in f:
#     a.append(int(line))
# f.close()
# max1 = 0  # для максимальной суммы показаний пары, между измерениями осадков которой прошло не менее K минут
# max_l = 0  # для максимальной разницы в минутах
# for i in range(k, n):  # чтобы сразу начинать с элемента K(мини-оптимизация)
#     max_l = max(max_l, a[i - k])  # берем последний элемент до текущего,
#     так как в максимуме уже содержится максимальный элемент до текущего(кроме последнего), с которым его можно сравнить
#     max1 = max(max1, a[i] + max_l)  # максимальная сумма текущего эл-та с максимальным элементом до него,
#     удовлетворяющих условию(по K)
# print(max1)

#  max_l - это максимальный элемент до текущего, с которым текущий можно сложить

'''Дана последовательность натуральных чисел. Необходимо найти максимально возможную сумму её непрерывной 
подпоследовательности, в которой количество чётных элементов кратно k=10.
Входные данные.
Файл A
Файл B
Первая строка входного файла содержит целое число N— общее количество чисел в наборе. Каждая из следующих N строк 
содержит одно число. Гарантируется, что общая сумма всех чисел не превышает 2·109.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. В ответе укажите два числа: 
сначала значение искомой суммы для файла A, затем для файла B.'''
# f = open('27_25.txt', 'r', encoding='utf-8')
# n = int(f.readline())  # кол-во всех чисел
# a = []  # список чисел
# for line in f:
#     a.append(int(line))
# f.close()
# max1 = 0  # максимальная из сумм эл-тов подходящей последовательности
# for i in range(n):  # индекс эл-та, с которого начинается подпоследовательность
#     s = 0  # сумма эл-тов подпоследовательности
#     k = 0  # кол-во четных эл-тов подпоследовательности
#     for j in range(i, n):
#         s += a[j]  # добавляем к сумме новый элемент_новая подпоследовательность
#         if a[j] % 2 == 0: # если эл-т четный, то увеличиваем счетчик четных эл-тов
#             k += 1
#         if k % 10 == 0: # если число четных эл-то подпоследовательности кратно 10
#             max1 = max(max1, s)  # переприсваиваем максимальную из сумм
# print(max1)














# f = open('27_25.txt', 'r', encoding='utf-8')
# n = int(f.readline())  #кол-во последовательности
# k = 0  # счетчик для кол-ва четных чисел
# s = 0  # общая сумма чисел
# mins = {0: [0, 0]}  # словарь с парой
# for i in range(1, 10):
#     mins[i] = [0, 0]  # создаем пары для всех остатков для деления на 10
# #  ключ словаря (до :)- это остаток от деления на 10 кол-ва четных чисел
# #  значение от ключа(после :) - это кортеж: пара в которой 1-ое число-минимальная сумма с остатком кол-ва четных чисел на 10 = ключу
# #  второе число - это максимальная сумма с остатком кол-ва четных чисел на 10 = ключу
# for i in range(1, n + 1):   #  проходимся по каждому числу, i-номер по счету числа
#     t = int(f.readline())
#     s += t  #  к общей сумме добавляем очередное число
#     if t % 2 == 0:  # если число четное
#         k += 1  # увеличиваем счетчик
#     if mins[k % 10][0] == 0:  # если до этого такой последовательности с таким остатком к на 10 не было
#         mins[k % 10][0] = s  # минимальная сумма для такого к % 10
#     mins[k % 10][1] = s  # максимальная сумма для такого к % 10
# if k % 10 == 0:  # если k для всех чисел кратно 10
#     print(s)
# else:
#     m = 0  # максимальная сумма
#     for i in range(1, k % 10 + 1):  # проходимся по всем остаткам от 1 до k % 10
#         if mins[i][1] - mins[i][0] > m:  # если разность максимальной и минимальной суммы(k для разности кратно 10) > максимума
#             m = max(m, mins[i][1] - mins[i][0])
#     if mins[0][1] > m:  # если максимальная сумма с k кратным 10 > максимума
#         m = mins[0][1]
#     print(m)














